#pragma config(Sensor, port2,  ArmBottomBumper, sensorVexIQ_Touch)
#pragma config(Sensor, port3,  Main_Gyro,      sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  LED,            sensorVexIQ_LED)
#pragma config(Sensor, port7,  CenterColor,    sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          Left,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          Intake,        tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          Right,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          CubeClaw,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         ArmRight,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         ArmLeft,       tmotorVexIQ, PIDControl, reversed, encoder)
//#pragma config(Sensor, port8,  CrossColor,     sensorVexIQ_ColorGrayscale)
//#pragma config(Sensor, port12, BallDetect,     sensorVexIQ_Touch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int PickupBonusSequenceState; // defines the variable that is used to tell what state the Pickup Bonus Sequence is in
int PlaceBonusSequenceState; // defines the variable that is used to tell what state the Place Bonus Sequence is in

float Height0 = 0; //Floor 2", 8/16
float Height1 = -300; //Position for Cube Raise 5", 8/16
float Height2 = -500; // 9", 15/16
float Height3 = -700; //Ride Height 9", 15/16  //11" 8/16//
float Height4 = -1000; //Place Cube on Low Score Platform 12" 14/16
//float Height5 = -1000; //Height4 = 850;
int ArmPresetValue = 0; //The preset number that tells the preset code how high to move the arm

void driveDistance(float distance) { // function that converts mm into rotations / degrees so the robot can then use the built in PIDcontroller to turn that ammount
	moveMotorTarget(Left, (distance/200*360*2.6666666666666666666666666666666666666666666666666666666666666666666666666666666666 /*CorrectionRatioforDrivingSequences*/), 80); // moves the motors according to the output variable from 'MoveDistanceRotations'
	moveMotorTarget(Right, (distance/200*360*2.6666666666666666666666666666666666666666666666666666666666666666666666666666666666 /*CorrectionRatioforDrivingSequences*/), 80);
};

bool Turn(int goHere, float speed){
	return false;
	if(goHere < 0){
		goHere += 360;
	}
	int currentLoc = getGyroHeading(Main_Gyro);
	int toGo = currentLoc - goHere;
	if((toGo <= 180 && toGo >=0) || (toGo < 0 && toGo <= -180)){
		repeatUntil(getGyroHeading(Main_Gyro) == goHere || getGyroHeading(Main_Gyro) == goHere - 360){
			setMotor(Left, speed);
			setMotor(Right, -speed);
			return false;
		}
	}
	else if((toGo > 180 && toGo >= 0) || (toGo < 0 && toGo > -180)){
		repeatUntil(getGyroHeading(Main_Gyro) == goHere || getGyroHeading(Main_Gyro) == goHere - 360){
			setMotor(Left, -speed);
			setMotor(Right, speed);
			return false;
		}
	}
	stopMultipleMotors(Left, Right);
	return true;
}

bool TurnDegrees (float varTurnDegrees) { // turn PID function that returns true or false once finished
	static bool InProgressTask; // defines the static bool that keeps the function looping until it has completed the turn
	if (!InProgressTask) { // starts code while it hasn't completed the turn
		resetGyro(Main_Gyro); // resets the gyro
		if (varTurnDegrees>0) { // checks whether the setpoint (where we want to be) is greater than 0 so we turn right or if its less than 0 it turns Left
			setMotorSpeed(Left, 50); // turns Right
			setMotorSpeed(Right, -50);
			} else {
			setMotorSpeed(Left, -50); // turns Left
			setMotorSpeed(Right, 50);
		};
	};
	InProgressTask = true; // stops the above code
	if ((getGyroDegrees(Main_Gyro)>varTurnDegrees && varTurnDegrees>0) || (getGyroDegrees(Main_Gyro)<varTurnDegrees && varTurnDegrees<0)) { // if the robot has turned to the setpoint then stop the Motors
		InProgressTask = false; // starts above code again if it has overshot
		setMotorSpeed(Left, 0); // stops both motors
		setMotorSpeed(Right, 0);
		return true; // returns true if it has finished so that the sequence can move to the next command

	};
	return false; // returns false if it has not finished so that the sequence waits until it is finished
};

void ArmHeightMove() { //moves the arm to the defined positions (height 0, Height1, Height2, etc) based on the variable ArmPresetValue
	switch(ArmPresetValue) {  //moves the arm by reading the variable (ArmPresetValue)
	case 0://Floor
		setMotorTarget(ArmLeft, Height0, 100);
		setMotorTarget(ArmRight, Height0, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 1://
		setMotorTarget(ArmLeft, Height1, 100);
		setMotorTarget(ArmRight, Height1, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 2://
		setMotorTarget(ArmLeft, Height2, 100);
		setMotorTarget(ArmRight, Height2, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 3://Static Height / Moving height for balance
		setMotorTarget(ArmLeft, Height3, 100);
		setMotorTarget(ArmRight, Height3, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 4://
		setMotorTarget(ArmLeft, Height4, 100);
		setMotorTarget(ArmRight, Height4, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	};
};

//////////////////////////////////////////////////////
//							 Place cube Sequence								//
//////////////////////////////////////////////////////

void PickupBonusSequence () {
	static int LastState;
	bool P1;

	if (PickupBonusSequenceState !=LastState) {
		P1 = true;
		resetTimer(T1);
		LastState = PickupBonusSequenceState;
	}
	else {
		P1 = false;
	};
	switch (PickupBonusSequenceState){
	case 1:
		if (getJoystickValue(BtnEUp)==1) {
			PickupBonusSequenceState = 2;
		};
		break;

	case 2:
		if (P1) {
			ArmPresetValue=3;
			ArmHeightMove();
			delay(800);
			driveDistance(600);
			//debugging for accuracy
			//delay(10000);
			//
			delay(500);
		};
		if (getMotorZeroVelocity(Left)) {
			PickupBonusSequenceState = 3;
		};
		break;

	case 3:
		if (P1) {
			driveDistance(-100);
			delay(400);
			ArmPresetValue=2;
			ArmHeightMove();
			delay(800);

		};
		if (getMotorZeroVelocity(ArmLeft) || (getTimerValue(T1)>3000)) {
			PickupBonusSequenceState = 4;
		};
		break;

	case 4:
		if (P1) {
			driveDistance(-600);
			delay(800);
			ArmPresetValue=0;
			ArmHeightMove();
			delay(100);
		};
		if(getTimerValue(T1)>1500) {
			ArmHeightMove();
		};
		if (getMotorZeroVelocity(Left) || (getTimerValue(T1)>3000)) {
			PickupBonusSequenceState = 1;
		};
		break;

		/*	case 5:
		if (TurnDegrees(90.0)) {
		PickupBonusSequenceState =1;
		};
		break;
		*/
	default: PickupBonusSequenceState = 1;
	};
};

//////////////////////////////////////////////////////
//							 Pickup cube Sequence								//
//////////////////////////////////////////////////////

void PlaceBonusSequence () {
	static int LastState2;
	bool P2;

	if (PlaceBonusSequenceState !=LastState2) {
		P2 = true;
		resetTimer(T1);
		LastState2 = PlaceBonusSequenceState;
	}
	else {
		P2 = false;
	};
	switch (PlaceBonusSequenceState){
	case 1:
		if (getJoystickValue(BtnFUp)==1) {
			PlaceBonusSequenceState = 2;
		};
		break;

	case 2:
		if (P2) {
			ArmPresetValue=3;
			ArmHeightMove();
			delay(800);
			driveDistance(600);
			//debugging for accuracy
			//delay(10000);
			//
			delay(500);
		};
		if (getMotorZeroVelocity(Left)) {
			PlaceBonusSequenceState = 3;
		};
		break;

	case 3:
		if (P2) {
			driveDistance(-100);
			delay(400);
			ArmPresetValue=2;
			ArmHeightMove();
			delay(800);

		};
		if (getMotorZeroVelocity(ArmLeft) || (getTimerValue(T1)>3000)) {
			PlaceBonusSequenceState = 4;
		};
		break;

	case 4:
		if (P2) {
			driveDistance(-600);
			delay(800);
			ArmPresetValue=0;
			ArmHeightMove();
			delay(100);
		};
		if(getTimerValue(T1)>1500) {
			ArmHeightMove();
		};
		if (getMotorZeroVelocity(Left) || (getTimerValue(T1)>3000)) {
			PlaceBonusSequenceState = 1;
		};
		break;


	default: PlaceBonusSequenceState = 1;
	};
};

void ArmReset() { // resets the arm if the bottom bumper is pressed
	if (getBumperValue(ArmBottomBumper)==1) {
		resetMotorEncoder(ArmLeft);
		resetMotorEncoder(ArmRight);
		setTouchLEDColor(LED,colorBlue);
		setTouchLEDColor(LED,colorNone);
	}
}
task main()
{
	while (true) {
		ArmReset();
			PickupBonusSequence();
		PlaceBonusSequence();
};

}
