#pragma config(Sensor, port2,  ArmBottomBumper, sensorVexIQ_Touch)
#pragma config(Sensor, port3,  Main_Gyro,      sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  LED,            sensorVexIQ_LED)
#pragma config(Sensor, port7,  CenterColor,    sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  CrossColor,     sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port12, BallDetect,     sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          Left,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          Intake,        tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          Right,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          CubeClaw,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         ArmRight,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         ArmLeft,       tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//VIQC_SquaredAway_CompCode
/*************************************PROGRAMMER NOTES*****************************************************//*
/*1*//* get odometry working
/*2*//* add special stuff
/*3*//* fix sequences
/*4*//*
/*5*//*
/*6*//*
/*7*//*
/*8*//*
/*9*//*
/*10*//*
/*11*//*
/*12*//*
/*13*//*
/*14*//*
/*15*//*
*//*End of Notes Main Program Code is Below */

//int gyrodriftrate = 37;
long gyroValue;
long gyroError;

int PickupBonusSequenceState; // defines the variable that is used to tell what state the Pickup Bonus Sequence is in
int PlaceBonusSequenceState; // defines the variable that is used to tell what state the Place Bonus Sequence is in

bool intakeStarted; // defines the variable that waits until the intake button is pressed before starting Intake

float Height0 = 0; //Floor
float Height1 = -300; //Place HighScored Hub and Move MultiPusher Over Field Lines
float Height2 = -700; //Position HighScored Hub
float Height3 = -1100; //Static Height / Moving height for balance
float Height4 = -1500; //Bonus Hub Position
int ArmPresetValue = 0; // the preset number that tells the preset code how high to move the arm

void driveDistance(float distance) { // function that converts mm into rotations / degrees so the robot can then use the built in PIDcontroller to turn that ammount
	float MoveDistanceRotations=distance/200*360; //divides the input mm by 100 then times it by 360 to get the rotations / degrees
	moveMotorTarget(Left, MoveDistanceRotations, 100); // moves the motors according to the output variable from 'MoveDistanceRotations'
	moveMotorTarget(Right, MoveDistanceRotations, 100);
};

bool AutonTurn (float varAutonDegrees) { // turn PID function that returns true or false once finished
	resetGyro(Main_Gyro);
	if (varAutonDegrees>0) { // checks whether the setpoint (where we want to be) is greater than 0 so we turn right or if its less than 0 it turns Left
		setMotorSpeed(Left, 50); // turns Right
		setMotorSpeed(Right, -50);
		} else {
		setMotorSpeed(Left, -50); // turns Left
		setMotorSpeed(Right, 50);
	};
	if (getGyroDegrees(Main_Gyro)==varAutonDegrees) {
		setMotorSpeed(Left, 0); // stops both motors
		setMotorSpeed(Right, 0);
		return true;
		} else {
		return false;
	};
};

bool TurnDegrees (float varTurnDegrees) { // turn PID function that returns true or false once finished
	static bool InProgressTask; // defines the static bool that keeps the function looping until it has completed the turn
	if (!InProgressTask) { // starts code while it hasn't completed the turn
		resetGyro(Main_Gyro); // resets the gyro
		if (varTurnDegrees>0) { // checks whether the setpoint (where we want to be) is greater than 0 so we turn right or if its less than 0 it turns Left
			setMotorSpeed(Left, 50); // turns Right
			setMotorSpeed(Right, -50);
			} else {
			setMotorSpeed(Left, -50); // turns Left
			setMotorSpeed(Right, 50);
		};
	};
	InProgressTask = true; // stops the above code
	if ((getGyroDegrees(Main_Gyro)>varTurnDegrees && varTurnDegrees>0) || (getGyroDegrees(Main_Gyro)<varTurnDegrees && varTurnDegrees<0)) { // if the robot has turned to the setpoint then stop the Motors
		InProgressTask = false; // starts above code again if it has overshot
		setMotorSpeed(Left, 0); // stops both motors
		setMotorSpeed(Right, 0);
		return true; // returns true if it has finished so that the sequence can move to the next command

	};
	return false; // returns false if it has not finished so that the sequence waits until it is finished
};

void ArmHeightMove() { //moves the arm to the defined positions (height 0, Height1, Height2, etc) based on the variable ArmPresetValue
	switch(ArmPresetValue) {  //moves the arm by reading the variable (ArmPresetValue)
	case 0://Floor
		setMotorTarget(ArmLeft, Height0, 100);
		setMotorTarget(ArmRight, Height0, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 1://
		setMotorTarget(ArmLeft, Height1, 100);
		setMotorTarget(ArmRight, Height1, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 2://
		setMotorTarget(ArmLeft, Height2, 100);
		setMotorTarget(ArmRight, Height2, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 3://Static Height / Moving height for balance
		setMotorTarget(ArmLeft, Height3, 100);
		setMotorTarget(ArmRight, Height3, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	case 4://
		setMotorTarget(ArmLeft, Height4, 100);
		setMotorTarget(ArmRight, Height4, 100);
		setTouchLEDColor(LED,colorOrange);
		break;

	};
};

void GyroCustomCalibration(int count = 30) {
	startGyroCalibration( Main_Gyro, gyroCalibrateSamples512 );
	// delay so calibrate flag can be set internally to the gyro
	wait1Msec(100);

	// wait for calibration to finish or 2 seconds, whichever is longer
	while( getGyroCalibrationFlag(Main_Gyro) || (count-- > 0) ) {
		wait1Msec(100);
	} resetGyro(Main_Gyro);
};

//////////////////////////////////////////////////////
//							 Place cube Sequence								//
//////////////////////////////////////////////////////

void PickupBonusSequence () {
	static int LastState;
	bool P1;

	if (PickupBonusSequenceState !=LastState) {
		P1 = true;
		resetTimer(T1);
		LastState = PickupBonusSequenceState;
	}
	else {
		P1 = false;
	};
	switch (PickupBonusSequenceState){
	case 1:
		if (getJoystickValue(BtnEUp)==1) {
			PickupBonusSequenceState = 2;
		};
		break;

	case 2:
		if (P1) {
			ArmPresetValue=3;
			ArmHeightMove();
			delay(800);
			driveDistance(600);
			delay(500);
		};
		if (getMotorZeroVelocity(Left)) {
			PickupBonusSequenceState = 3;
		};
		break;

	case 3:
		if (P1) {
			driveDistance(-100);
			delay(400);
			ArmPresetValue=2;
			ArmHeightMove();
			delay(800);

		};
		if (getMotorZeroVelocity(ArmLeft) || (getTimerValue(T1)>3000)) {
			PickupBonusSequenceState = 4;
		};
		break;

	case 4:
		if (P1) {
			driveDistance(-600);
			delay(800);
			ArmPresetValue=0;
			ArmHeightMove();
			delay(100);
		};
		if(getTimerValue(T1)>1500) {
			ArmHeightMove();
		};
		if (getMotorZeroVelocity(Left) || (getTimerValue(T1)>3000)) {
			PickupBonusSequenceState = 1;
		};
		break;

		/*	case 5:
		if (TurnDegrees(90.0)) {
		PickupBonusSequenceState =1;
		};
		break;
		*/
	default: PickupBonusSequenceState = 1;
	};
};

//////////////////////////////////////////////////////
//							 Pickup cube Sequence								//
//////////////////////////////////////////////////////

void PlaceBonusSequence () {
	static int LastState;
	bool P1;

	if (PlaceBonusSequenceState !=LastState) {
		P1 = true;
		resetTimer(T1);
		LastState = PlaceBonusSequenceState;
	}
	else {
		P1 = false;
	};
	switch (PlaceBonusSequenceState){
	case 1:
		if (getJoystickValue(BtnFUp)==1) {
			PlaceBonusSequenceState = 2;
		};
		break;

	case 2:
		if (P1) {
			if (TurnDegrees(35.0)) {
				PickupBonusSequenceState = 3;
			};
			delay(100);
		};
		break;

	case 3:
		if (P1) {
			driveDistance(70);
			delay(100);
		};
		if (getMotorZeroVelocity(Left) || (getTimerValue(T1)>1500)) {
			PlaceBonusSequenceState = 4;
		};
		break;

	case 4:
		if (TurnDegrees(-70.0)) {
			PickupBonusSequenceState = 5;
		};
		break;

	case 5:
		if (P1) {
			ArmPresetValue = 3;
			delay(500);
			driveDistance(-40);
			delay(100);

		};
		if (getMotorZeroVelocity(Left) || (getTimerValue(T1)>1500)) {
			PlaceBonusSequenceState = 6;
		};
		/*		if(getTimerValue(T1)>1500) {
		ArmPresetValue = 0;
		ArmHeightMove();
		}; 														*/
		break;

	case 6:
		if (TurnDegrees(35.0)) {
			PickupBonusSequenceState = 1;
		};
		break;


	default: PlaceBonusSequenceState = 1;
	};
};

void GrayscaleDetector () {
	if (getColorGrayscale(CenterColor)<15) {
		setTouchLEDColor(LED,colorRed);
	}

};
void ArmReset() { // resets the arm if the bottom bumper is pressed
	if (getBumperValue(ArmBottomBumper)==1) {
		resetMotorEncoder(ArmLeft);
		resetMotorEncoder(ArmRight);
		setTouchLEDColor(LED,colorBlue);
		setTouchLEDColor(LED,colorNone);
	}
}
/*
int SpeedLeft = 0;
int SpeedRight = 0;
int Heading = 0;
int HeadingStraight;






task keepStraight(){
while(true) {
HeadingStraight=0;
if(gyroValue<-2){HeadingStraight=-6;}
if(gyroValue>2){HeadingStraight=6;}
wait1Msec(100);
setMotorSpeed(Left, SpeedLeft-HeadingStraight);
setMotorSpeed(Right,SpeedRight +HeadingStraight);
}}

float AutonDriveMM;
float AutonDriveDEG;

void DriveStraight(float AutonDriveMM) {
float AutonDriveDEG = AutonDriveMM/200*360*360; //divides the input mm by 200 then times it by 360 to get the rotations / degrees
SpeedLeft=75;
SpeedRight=75;
startTask(keepStraight);
waitUntil (getMotorEncoder(Left)>AutonDriveDEG);//Forward 3.5 rotations
stopTask(keepStraight);
stopMultipleMotors(Left,Right);
};

*/


task gyroTask()
{
	long rate;
	long angle, lastAngle;
	lastAngle = 0;
	gyroError=0;
	// Change sensitivity, this allows the rate reading to be higher
	setGyroSensitivity(Main_Gyro, gyroNormalSensitivity);
	//Reset the gyro sensor to remove any previous data.
	resetGyro(Main_Gyro);
	wait1Msec(1000);
	repeat (forever) {
		rate = getGyroRate(Main_Gyro);
		angle = getGyroDegrees(Main_Gyro);
		// If big rate then ignore gyro changes
		if( abs( rate ) < 2 )
		{
			if( angle != lastAngle )
				gyroError += lastAngle - angle;
		}
		lastAngle = angle;
		gyroValue = angle + gyroError;
		wait1Msec(10);
	}
}

bool AutonStarted = false;

task Auton() {
	////////////////////////////////////////////////
	//									Auton Code 								//
	////////////////////////////////////////////////
while(AutonStarted) {
	driveDistance(100);
	if (AutonTurn(90.0)) {
		delay(100);
	};
	driveDistance(100);
	AutonStarted = false;
};
}
task main() { // main program code
	resetMotorEncoder(ArmLeft);	 //Resets Left Arm Motor Encoder to 0
	resetMotorEncoder(ArmRight); //Resets Right Arm Motor Encoder to 0
	intakeStarted = false; // sets the variable that starts the intake to false
	resetTimer(timer2);
	GyroCustomCalibration(30);
	delay(10);
	startTask(gyroTask);
	while(/*timer2 < 90*/true) //while the program is running do this:
	{
		if (getTouchLEDValue(LED)){
			startTask(Auton);
			AutonStarted = true;
		}
		while (AutonStarted) {
			setTouchLEDColor(LED,colorNone);
			ArmReset();
			GrayscaleDetector();
			//Display Code
			displayTextLine(0, "Arm Height=%d", ((getMotorEncoder(ArmLeft)) + (getMotorEncoder(ArmRight)))/2); //Displays Average of motor encoders position
			displayVariableValues(1,ArmPresetValue); // displays the preset value for the height of the arm
			displayTextLine(2, "Gyro=%d", getGyroDegrees(Main_Gyro)); // displays the gyro value in degrees
			displayVariableValues(3, PickupBonusSequenceState);
			displayVariableValues(4, PlaceBonusSequenceState);
			displayVariableValues(5, Height0);
			//Sequences
			PickupBonusSequence();
			PlaceBonusSequence();



		};
	};
}

//END
